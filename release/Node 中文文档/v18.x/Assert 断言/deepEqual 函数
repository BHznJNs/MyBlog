{"NM":"deepEqual 函数","CTS":[{"NT":"h","CT":"assert.deepEqual 函数","CL":"#333"},{"NT":"p","CT":"assert.deepEqual(actual, expected[, message])","CL":"#333"},{"NT":"floor","CTS":[{"NT":"h","CT":"历史变更","CL":"#333"},{"NT":"table","CTS":[["版本","改变"],["v18.0.0","正则表达式的 lastIndex 属性现在也可以被比较了。"],["v16.0.0, v14.18.0","在旧版 assert 模式下，将稳定性从废弃的(Deprecated)改为遗留的(Legacy)。"],["v14.0.0","当两边都是 NaN 时，现在被认为是相同的。"],["v12.0.0","类型标签现在可以被正确比较，并且有一些小调整使检查结果更为正常。"],["v9.0.0","Error 的 name 和 message 现在也可以被正确比较了。"],["v8.0.0","Set 和 Map 类型也可以被比较了。"],["v6.4.0, v4.7.1","类型数组切片现在可以被正确处理。"],["v6.1.0, v4.5.0","循环引用的对象现在可以作为输入使用。"],["v5.10.1, v4.4.3","正确处理 Uint8Array 类型的数组。"],["v0.1.21","于 v0.1.21 版本被添加。"]]},{"NT":"p","CT":"译注：类型标签// type tag //指的是``typeof``的返回值。","CL":"#333"}]},{"NT":"list","CTS":[{"NT":"li","CT":"``actual``:any","CL":"#333"},{"NT":"li","CT":"``expected``:any","CL":"#333"},{"NT":"li","CT":"``message``:string / error","CL":"#333"}],"OL":false},{"NT":"floor","CTS":[{"NT":"h","CT":"在严格 assert 模式下","CL":"#333"},{"NT":"p","CT":"作为 assert.deepStrictEqual() 的同名函数。","CL":"#333"}]},{"NT":"floor","CTS":[{"NT":"h","CT":"在旧版 assert 模式下","CL":"#333"},{"NT":"p","CT":"稳定性：遗留的(Legacy)，请使用 assert.deepStrictEqual() 作为替代。","CL":"#00f"},{"NT":"p","CT":"``actual``和``expected``参数的检测深度相等。可以考虑使用``assert.deepStrictEqual()``替代。使用``assert.deepEqual()``可能会有出乎意料的结果。","CL":"#333"},{"NT":"p","CT":"深层比较(Deep Equal)意味着输入的可枚举属性都会被通过以下规则进行递归比较。","CL":"#333"},{"NT":"floor","CTS":[{"NT":"h","CT":"比较细节","CL":"#333"},{"NT":"list","CTS":[{"NT":"li","CT":"基本数据类型会被使用``==``操作符进行比较，但 NaN 是个例外。当两边的值都为 NaN 时才会被认定为相同。","CL":"#333"},{"NT":"li","CT":"对象的类型标签必须一致。","CL":"#333"},{"NT":"li","CT":"仅考虑可枚举的自有属性。","CL":"#333"},{"NT":"li","CT":"无论是不是可枚举属性，``Error``的 name 和 message 属性都会被比较。","CL":"#333"},{"NT":"li","CT":"对象包装器既会被作为对象比较，也会被比较其字面量。\n译注：对象包装器(Object wrapper)可让本没有属性和方法的 js 基本类型拥有可调用的属性和方法，如``string``类型本为基本数据类型，但却像对象一般有``substr``等方法，这就是对象包装器的作用。","CL":"#333"},{"NT":"li","CT":"对象属性会被无序地比较。","CL":"#333"},{"NT":"li","CT":"``Map``的键和``Set``中的元素都会被无序地比较。","CL":"#333"},{"NT":"li","CT":"当两边出现不相同元素或循环引用时，比较会停止。","CL":"#333"},{"NT":"li","CT":"不会比较对象的``[[Prototype]]``。","CL":"#333"},{"NT":"li","CT":"``Symbol``类型的属性不会被比较。","CL":"#333"},{"NT":"li","CT":"``WeakMap``和``WeakSet``类型的输入不会被根据它们的值进行比较。","CL":"#333"},{"NT":"li","CT":"正则表达式的``lastIndex``,``flags``和``source``属性都会被比较，即使它们不是可枚举属性。","CL":"#333"}],"OL":false}]},{"NT":"hr","CT":""},{"NT":"p","CT":"下面这个例子不会报错，因为基本类型输入会被使用``==``操作符进行比较。","CL":"#333"},{"NT":"code","LG":"javascript","CT":"import assert from 'node:assert';\n// 警告，这不会导致报错！\n\nassert.deepEqual('+00000000', false);"},{"NT":"p","CT":"“深层”比较意味着参数子元素中对象的可枚举自有属性也会被进行比较：","CL":"#333"},{"NT":"code","LG":"javascript","CT":"import assert from 'node:assert';\n\nconst obj1 = {\n  a: {\n    b: 1\n  }\n};\nconst obj2 = {\n  a: {\n    b: 2\n  }\n};\nconst obj3 = {\n  a: {\n    b: 1\n  }\n};\nconst obj4 = Object.create(obj1);\n\nassert.deepEqual(obj1, obj1);\n// 相等\n\n// `b`的值不相等：\nassert.deepEqual(obj1, obj2);\n// AssertionError:\n// { a: { b: 1 } }\n// deepEqual\n// { a: { b: 2 } }\n\nassert.deepEqual(obj1, obj3);\n// 相等\n\n// 原型会被忽略：\nassert.deepEqual(obj1, obj4);\n// AssertionError:\n// { a: { b: 1 } }\n// deepEqual\n// {}"}]},{"NT":"p","CT":"如果输入值(actual 和 expected)不相等，则会抛出一个带有  message 属性(其值与函数参数中的 message 相同)的 ``AssertionError``错误。如果未传入 message 参数，则程序会自动生成错误信息。如果 message 参数的类型是一个 error 实例，则该实例会代替``AssertionError``被抛出。","CL":"#333"}]}