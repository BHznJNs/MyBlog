{"NM":"throws 函数","CTS":[{"NT":"h","CT":"assert.throws 函数","CL":"#333"},{"NT":"p","CT":"assert.throws(fn[, error][, message])","CL":"#333"},{"NT":"floor","CTS":[{"NT":"h","CT":"变更历史","CL":"#333"},{"NT":"table","CTS":[["版本","改变"],["v10.2.0","error 参数现在可以是一个包含着正则表达式的对象。"],["v9.9.0","error 参数现在也可以是一个对象。"],["v4.2.0","error 参数现在可以是一个箭头函数。"],["v0.1.21","于 v0.1.21 版本被添加。"]]}]},{"NT":"list","CTS":[{"NT":"li","CT":"``fn``:function","CL":"#333"},{"NT":"li","CT":"``error``:RegExp / Function / Object / Error ","CL":"#333"},{"NT":"li","CT":"``message``:string","CL":"#333"}],"OL":false},{"NT":"p","CT":"检测 fn 是否有抛出错误，如果没有抛出错误，则报错。","CL":"#333"},{"NT":"p","CT":"如果被指定，error 参数可以是一个类、正则表达式、一个有效的函数、一个有效的对象(其中每一个都会被进行严格深层比较)或者一个 error 实例(其中每一个都会被进行严格深层比较，包括不可枚举的 message 和 name 属性)。当使用对象作为 时，你也可以使用正则表达式来检验字符串类型的属性。下面有相关的示例。","CL":"#333"},{"NT":"p","CT":"如果传入了 message 参数，并且 fn 没有抛出错误或者错误验证失败，message 会跟在``AssertionError``的错误信息之后。","CL":"#333"},{"NT":"hr"},{"NT":"p","CT":"自定义的 验证对象/错误实例：","CL":"#333"},{"NT":"code","LG":"javascript","CT":"import assert from 'node:assert/strict';\n\nconst err = new TypeError('Wrong value');\nerr.code = 404;\nerr.foo = 'bar';\nerr.info = {\n  nested: true,\n  baz: 'text'\n};\nerr.reg = /abc/i;\n\nassert.throws(\n  () =&gt; {\n    throw err;\n  },\n  {\n    name: 'TypeError',\n    message: 'Wrong value',\n    info: {\n      nested: true,\n      baz: 'text'\n    }\n    // 只有检验对象的属性才会被比较。\n    // 使用嵌套的对象需要存在所有属性。\n    // 不然检测将会失败。\n  }\n);\n\n\n// 使用正则表达式来检测错误属性。\nassert.throws(\n  () =&gt; {\n    throw err;\n  },\n  {\n    // `name` 和 `message` 属性都是字符串(在 error 实例中)\n    // 并且在这些属性中使用正则表达式会在对应的字符串中匹配。\n    // 如果匹配不成功，则会报错。\n    name: /^TypeError$/,\n    message: /Wrong/,\n    foo: 'bar',\n    info: {\n      nested: true,\n      // 你不能对嵌套属性使用正则表达式。\n      baz: 'text'\n    },\n    // `reg` 属性包含一个正则表达式并且只有当\n    // 检验对象包含相同的正则表达式时才会通过。\n    reg: /abc/i\n  }\n);\n\n\n// 因为不同的 `message` 和 `name` 属性而验证错误：\nassert.throws(\n  () =&gt; {\n    const otherErr = new Error('Not found');\n    // 从 `err` 到 `otherErr` 复制所有可枚举属性。\n    for (const [key, value] of Object.entries(err)) {\n      otherErr[key] = value;\n    }\n    throw otherErr;\n  },\n  // 当使用一个 error 实例作为验证对象时，\n  // error 的 `message` 和 `name` 属性也会被检测。\n  err\n);\n"},{"NT":"hr"},{"NT":"p","CT":"使用构造器来检测实例。","CL":"#333"},{"NT":"code","LG":"javascript","CT":"import assert from 'node:assert/strict';\n\nassert.throws(\n  () =&gt; {\n    throw new Error('Wrong value');\n  },\n  Error\n);"},{"NT":"hr"},{"NT":"p","CT":"使用正则表达式来检验错误信息。","CL":"#333"},{"NT":"p","CT":"使用正则表达式时会调用错误对象的``toString``方法，其中也将包含错误名称。","CL":"#333"},{"NT":"code","LG":"javascript","CT":"import assert from 'node:assert/strict';\n\nassert.throws(\n  () =&gt; {\n    throw new Error('Wrong value');\n  },\n  /^Error: Wrong value$/\n);"},{"NT":"hr"},{"NT":"p","CT":"自定义错误检测：","CL":"#333"},{"NT":"p","CT":"当检测通过时，此方法会返回 true，反之则会返回一个``AssertionError``。","CL":"#333"},{"NT":"code","LG":"javascript","CT":"import assert from 'node:assert/strict';\n\nassert.throws(\n  () =&gt; {\n    throw new Error('Wrong value');\n  },\n  (err) =&gt; {\n    assert(err instanceof Error);\n    assert(/value/.test(err));\n    // 阻止从检测函数中返回除了 `true` 外的任何东西。\n    // 此外，检测的哪一部分出错并不明确。\n    // 所以，抛出一个检测特定失败位置的错误(就像\n    // 这个例子)，并尽可能加上一些有用的 debug 信息。\n    return true;\n  },\n  'unexpected error'\n);\n"},{"NT":"hr"},{"NT":"p","CT":"error 不能是字符串类型。如果一个字符串被传入作为第二个参数，则 error 参数会被忽略而这个字符串会被作为 message 参数输入。这会导致容易被忽略的错误。使用相同的字符串作为 error 参数和被抛出的错误信息会导致``ERR_AMBIGUOUS_ARGUMENT``错误。如果你想使用字符串作为第二个参数，请认真阅读下面的示例：","CL":"#333"},{"NT":"code","LG":"javascript","CT":"import assert from 'node:assert/strict';\n\nfunction throwingFirst() {\n  throw new Error('First');\n}\n\nfunction throwingSecond() {\n  throw new Error('Second');\n}\n\nfunction notThrowing() {}\n\n// 第二个参数是一个字符串，并且输入的函数抛出了一个错误。\n// 这一个例子不会报错因为方法传入的字符串没有匹配到\n// 函数抛出的错误的错误信息。\nassert.throws(throwingFirst, 'Second');\n\n// 在这第二个例子中，传入的字符串与函数中的错误信息相同，\n// 因为没法判断使用者是否想匹配错误信息，\n// Node.js 抛出了一个 `ERR_AMBIGUOUS_ARGUMENT` 错误。\nassert.throws(throwingSecond, 'Second');\n// TypeError [ERR_AMBIGUOUS_ARGUMENT]\n\n\n// 在这个例子中，方法输入的字符串只被用作 message\n// 并且输入的函数没有抛出错误。\nassert.throws(notThrowing, 'Second');\n// AssertionError [ERR_ASSERTION]:\n// Missing expected exception: Second\n\n// 如果你想要匹配错误信息，请像下面这样做。\n// 这样不会报错因为错误信息被正则匹配。\nassert.throws(throwingSecond, /Second$/);\n\n// 如果错误信息未被匹配，则会抛出一个\n// AssertionError 错误。\nassert.throws(throwingFirst, /Second$/);\n// AssertionError [ERR_ASSERTION]"}]}