{"NM":"ok 函数","CTS":[{"NT":"h","CT":"assert.ok 函数","CL":"#333"},{"NT":"p","CT":"assert.ok(value[, message])","CL":"#333"},{"NT":"floor","CTS":[{"NT":"h","CT":"变更历史","CL":"#333"},{"NT":"table","CTS":[["版本","改变"],["v10.0.0","未传入参数使用此方法时现在会抛出预定义的错误信息。"],["v0.1.21","于 v0.1.21 版本被添加。"]]}]},{"NT":"list","CTS":[{"NT":"li","CT":"``value``:any","CL":"#333"},{"NT":"li","CT":"``message``:string / Error","CL":"#333"}],"OL":false},{"NT":"p","CT":"判断是否 value 为真值，此方法等效于``assert.equal(!!value, true, message)``。","CL":"#333"},{"NT":"p","CT":"如果 value 不是真值，则抛出一个带有 message 属性(其值与此方法输入的 message 参数的值相同)的``AssertionError``。如果 message 参数的值为 undefined，则抛出的错误信息会被设为默认信息。如果 message 是一个``Error``实例，其实例会代替``AssertionError``被抛出。如果没有参数被传入，则错误信息会被设为``'No value argument passed to `assert.ok()`'``。","CL":"#333"},{"NT":"p","CT":"值得注意的是，在 REPL 下此方法的错误信息会与在 JS 脚本文件中抛出的有所不同！接着看以获取详情。","CL":"#333"},{"NT":"code","LG":"javascript","CT":"import assert from 'node:assert/strict';\n\nassert.ok(true);\n// 无报错。\nassert.ok(1);\n// 无报错。\n\nassert.ok();\n// AssertionError:\n// No value argument passed to `assert.ok()`\n\nassert.ok(false, 'it\\'s false');\n// AssertionError: it's false\n\n// 在 repl下：\nassert.ok(typeof 123 === 'string');\n// AssertionError: false == true\n\n// 在一个脚本文件中(例如：test.js):\nassert.ok(typeof 123 === 'string');\n// AssertionError:\n// The expression evaluated to a falsy value:\n//\n//   assert.ok(typeof 123 === 'string')\n\nassert.ok(false);\n// AssertionError:\n// The expression evaluated to a falsy value:\n//\n//   assert.ok(false)\n\nassert.ok(0);\n// AssertionError:\n// The expression evaluated to a falsy value:\n//\n//   assert.ok(0)"},{"NT":"code","LG":"javascript","CT":"import assert from 'node:assert/strict';\n\n// 使用`assert()`效果相同：\nassert(0);\n// AssertionError:\n// The expression evaluated to a falsy value:\n//\n//   assert(0)"}]}