{"NM":"deepStrictEqual 函数","CTS":[{"NT":"h","CT":"assert.deepStrictEqual 函数","CL":"#333"},{"NT":"p","CT":"assert.deepStrictEqual(actual, expected[, message])","CL":"#333"},{"NT":"floor","CTS":[{"NT":"h","CT":"历史变更","CL":"#333"},{"NT":"table","CTS":[["版本","改变"],["v18.0.0","正则表达式的 lastIndex 属性现在也可以被比较了。"],["v9.0.0","可枚举的 Symbol 类型的属性现在可以被比较了。"],["v9.0.0","NaN 现在被使用 SameValueZero 进行比较了。"],["v8.5.0","Error 的 name 和 message 属性现在也可以被正确比较了。"],["v8.0.0","Set 和 Map 类型的内容也可以被比较了。"],["v6.1.0","带有循环引用的对象现在能被用作输入了。"],["v6.4.0, v4.7.1","类型数组切片现在能被正确处理了。"],["v5.10.1, v4.4.3","能够正确处理非 Uint8Array 类型的数组。"],["v1.2.0","于 v1.2.0 版本添加。"]]}]},{"NT":"list","CTS":[{"NT":"li","CT":"``actual``:any","CL":"#333"},{"NT":"li","CT":"``expected``:any","CL":"#333"},{"NT":"li","CT":"``message``:string / Error","CL":"#333"}],"OL":false},{"NT":"p","CT":"在``actual``和``expected``两个参数间进行深层比较。“深层”比较意味着参数子元素中对象的可枚举自有属性也会被通过以下规则进行比较。","CL":"#333"},{"NT":"floor","CTS":[{"NT":"h","CT":"比较细节","CL":"#333"},{"NT":"list","CTS":[{"NT":"li","CT":"基本数据类型使用``Object.is()``进行比较。","CL":"#333"},{"NT":"li","CT":"对象的类型标签必须一致。","CL":"#333"},{"NT":"li","CT":"``[[Prototype]]``的比较会使用``===``操作符。","CL":"#333"},{"NT":"li","CT":"只有可枚举的自有属性会参与比较。","CL":"#333"},{"NT":"li","CT":"无论是不是可枚举属性，``Error``的 name 和 message 属性都会被比较。","CL":"#333"},{"NT":"li","CT":"对象中可枚举的``Symbol``类型属性也会被比较。","CL":"#333"},{"NT":"li","CT":"对象包装器既会被作为对象比较，也会被比较其字面量。","CL":"#333"},{"NT":"li","CT":"对象属性会被无序地比较。","CL":"#333"},{"NT":"li","CT":"``Map``的键和``Set``中的元素都会被无序地比较。\n","CL":"#333"},{"NT":"li","CT":"当两边出现不相同元素或循环引用时，比较会停止。\n","CL":"#333"},{"NT":"li","CT":"``WeakMap``和``WeakSet``类型的输入不会被根据它们的值进行比较， 下面有更多相关细节。","CL":"#333"},{"NT":"li","CT":"正则表达式的``lastIndex``,``flags``和``source``属性都会被比较，即使它们不是可枚举属性。\n","CL":"#333"}],"OL":false}]},{"NT":"code","LG":"javascript","CT":"import assert from 'node:assert/strict';\n\n// 这样会报错，因为 1 !== '1'。\nassert.deepStrictEqual({ a: 1 }, { a: '1' });\n// AssertionError: Expected inputs to be strictly deep-equal:\n// + actual - expected\n//\n//   {\n// +   a: 1\n// -   a: '1'\n//   }\n\n// 下面的对象没有自有属性。\nconst date = new Date();\nconst object = {};\nconst fakeDate = {};\nObject.setPrototypeOf(fakeDate, Date.prototype);\n\n// 不同的原型：\nassert.deepStrictEqual(object, fakeDate);\n// AssertionError: Expected inputs to be strictly deep-equal:\n// + actual - expected\n//\n// + {}\n// - Date {}\n\n// 不同的类型标签：\nassert.deepStrictEqual(date, fakeDate);\n// AssertionError: Expected inputs to be strictly deep-equal:\n// + actual - expected\n//\n// + 2018-04-26T00:49:08.604Z\n// - Date {}\n\nassert.deepStrictEqual(NaN, NaN);\n// 此代码不会报错，因为`Object.is(NaN, NaN)`的返回值是 true。\n\n// 不同的解封装数字(unwrapped numbers)：\nassert.deepStrictEqual(new Number(1), new Number(2));\n// AssertionError: Expected inputs to be strictly deep-equal:\n// + actual - expected\n//\n// + [Number: 1]\n// - [Number: 2]\n\nassert.deepStrictEqual(new String('foo'), Object('foo'));\n// 此代码不会报错因为此字符串与对象在解封装前是相同的。\n// 译者注：`new string`返回的是一个对象\n// 如：\n// typeof new String(\"\")\n// 'object'\n\nassert.deepStrictEqual(-0, -0);\n// 不会报错\n\n// 不同的零：\nassert.deepStrictEqual(0, -0);\n// AssertionError: Expected inputs to be strictly deep-equal:\n// + actual - expected\n//\n// + 0\n// - -0\n\nconst symbol1 = Symbol();\nconst symbol2 = Symbol();\nassert.deepStrictEqual({ [symbol1]: 1 }, { [symbol1]: 1 });\n// 此代码不会报错因为输入的两个对象的键是同一个`Symbol`对象的引用。\n\nassert.deepStrictEqual({ [symbol1]: 1 }, { [symbol2]: 1 });\n// AssertionError [ERR_ASSERTION]: Inputs identical but not reference equal:\n//\n// {\n//   [Symbol()]: 1\n// }\n\nconst weakMap1 = new WeakMap();\nconst weakMap2 = new WeakMap([[{}, {}]]);\nconst weakMap3 = new WeakMap();\nweakMap3.unequal = true;\n\nassert.deepStrictEqual(weakMap1, weakMap2);\n// 此代码不会报错因为`WeakMap`类型无法进行比较。\n\n\n// 报错，因为`weakMap3`有一个`weakMap1`不具有的属性：\nassert.deepStrictEqual(weakMap1, weakMap3);\n// AssertionError: Expected inputs to be strictly deep-equal:\n// + actual - expected\n//\n//   WeakMap {\n// +   [items unknown]\n// -   [items unknown],\n// -   unequal: true\n//   }"},{"NT":"p","CT":"如果输入的值不相等，则程序会抛出一个带有  message 属性(其值与函数参数中的 message 相同)的``AssertionError``错误。如果未传入 message 参数，则程序会自动生成错误信息。如果 message 参数的类型是一个 error 实例，则该实例会代替``AssertionError``被抛出。","CL":"#333"}]}