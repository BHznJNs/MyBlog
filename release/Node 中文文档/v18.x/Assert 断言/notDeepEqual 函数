{"NM":"notDeepEqual 函数","CTS":[{"NT":"h","CT":"assert.notDeepEqual 函数","CL":"#333"},{"NT":"p","CT":"assert.notDeepEqual(actual, expected[, message])","CL":"#333"},{"NT":"floor","CTS":[{"NT":"h","CT":"变更历史","CL":"#333"},{"NT":"table","CTS":[["版本","改变"],["v16.0.0, v14.18.0","在旧版 assert 模式下，将稳定性从已废弃(Deprecated)改为遗留的(Legacy)。"],["v14.0.0","现在当两边的值都为 NaN 时会判断为相等。"],["v9.0.0","Error 的 name 属性和 message 属性现在能够被正确比较了。"],["v8.0.0","Set 和 Map 类型的内容现在也能被比较了。"],["v6.4.0, v4.7.1","类型数组的切片现在能够被正确处理了。"],["v6.1.0, v4.5.0","带有循环引用的对象现在能作为此方法的输入了。"],["v5.10.1, v4.4.3","现在能正确处理非 Uint8Array 类型的数组。"],["v0.1.21","于 v0.1.21 版本被添加。"]]}]},{"NT":"list","CTS":[{"NT":"li","CT":"``actual``:any","CL":"#333"},{"NT":"li","CT":"``expected``:any ","CL":"#333"},{"NT":"li","CT":"``message``:string / Error","CL":"#333"}],"OL":false},{"NT":"floor","CTS":[{"NT":"h","CT":"在严格 assert 模式下","CL":"#333"},{"NT":"p","CT":"相当于``assert.notDeepStrictEqual()``。","CL":"#333"}]},{"NT":"floor","CTS":[{"NT":"h","CT":"在旧版 assert 模式下","CL":"#333"},{"NT":"p","CT":"稳定性：遗留的(Legacy) | 请使用``assert.notDeepStrictEqual()``作为替代。","CL":"#00f"},{"NT":"p","CT":"深层地进行不等比较。与``assert.deepEqual()``比较规则相反。","CL":"#333"},{"NT":"code","LG":"javascript","CT":"import assert from 'node:assert';\n\nconst obj1 = {\n  a: {\n    b: 1\n  }\n};\nconst obj2 = {\n  a: {\n    b: 2\n  }\n};\nconst obj3 = {\n  a: {\n    b: 1\n  }\n};\nconst obj4 = Object.create(obj1);\n\nassert.notDeepEqual(obj1, obj1);\n// AssertionError: { a: { b: 1 } }\n// notDeepEqual\n// { a: { b: 1 } }\n\nassert.notDeepEqual(obj1, obj2);\n// 无报错。\n\nassert.notDeepEqual(obj1, obj3);\n// AssertionError: { a: { b: 1 } }\n// notDeepEqual\n// { a: { b: 1 } }\n\nassert.notDeepEqual(obj1, obj4);\n// 无报错。"},{"NT":"p","CT":"如果输入的值被判断为相等，则抛出一个带有 message 属性(其值与此方法输入的 message 参数的值相同)的``AssertionError``。如果 message 参数的值为 undefined，则抛出的错误信息会被设为默认信息。如果 message 是一个``Error``实例，其实例会代替``AssertionError``被抛出。","CL":"#333"}]}]}