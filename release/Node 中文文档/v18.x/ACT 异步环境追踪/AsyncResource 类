{"NM":"AsyncResource 类","CTS":[{"NT":"h","CT":"AsyncResource 类","CL":"#333"},{"NT":"floor","CTS":[{"NT":"h","CT":"历史变更","CL":"#333"},{"NT":"table","CTS":[["版本","改变"],["v16.4.0","此类现在的稳定性为稳定的(Stable)，先前为实验性(Experimental)。"]]}]},{"NT":"p","CT":"此类被设计作为嵌入器异步资源(embedder's async resourse)的拓展。通过此类，你可以轻易地触发异步资源的生命周期事件。","CL":"#333"},{"NT":"p","CT":"在一个 asyncResource 被实例化后，init 钩子会被调用。","CL":"#333"},{"NT":"hr"},{"NT":"p","CT":"下面是 AsyncResource API 用法的概览。","CL":"#333"},{"NT":"code","LG":"javascript","CT":"import { AsyncResource, executionAsyncId } from 'node:async_hooks';\n\n\n// AsyncResource() 旨在扩展。\n// 实例化一个 new AsyncResource() 也会触发 init 钩子。\n// 如果 triggerAsyncId 被忽略，则\n// async_hook.executionAsyncId() 会被用到。\nconst asyncResource = new AsyncResource(\n  type, { triggerAsyncId: executionAsyncId(), requireManualDestroy: false }\n);\n\n// 在此 resourse 的执行上下文中运行一个函数。\n// 这会\n// * 产生此 resourse 的上下文\n// * 在回调函数之前触发 AsyncHooks\n// * 调用传入的函数 `fn` \n// * 在回调函数之后触发 AsyncHooks\n// * 重置原来的执行上下文\nasyncResource.runInAsyncScope(fn, thisArg, ...args);\n\n// 调用 AsyncHooks 销毁回调函数。\nasyncResource.emitDestroy();\n\n// 给 AsyncResource 实例分配独一无二的 ID。\nasyncResource.asyncId();\n\n// 返回 AsyncResource 对应的触发器的 ID。\nasyncResource.triggerAsyncId();\n"},{"NT":"floor","CTS":[{"NT":"h","CT":"new AsyncResource(type[, options])","CL":"#333"},{"NT":"list","CTS":[{"NT":"li","CT":"``type``:string | 异步事件的类型。","CL":"#333"},{"NT":"li","CT":"``options``:Object","CL":"#333"},{"NT":"list","OL":false,"CTS":[{"NT":"li","CT":"``triggerAsyncId``:number | 创建此异步事件的执行上下文的 ID。默认为：executionAsyncId()。","CL":"#333"},{"NT":"li","CT":"``requireManualDestroy``:boolean | 如果被设为 true，当对象被垃圾回收时则会禁用 emitDestroy。此属性通常不需要设置(即使 emitDestroy 被手动调用)，除非 resource 的 asyncId 被检索到并且需要使用它调用敏感 API 的 emitDestroy。\n当被设为 false 时，emitDestroy 的调用只会发生在至少有一个活跃的 destroy 钩子的时候。\n默认：false。","CL":"#333"}]}],"OL":false},{"NT":"p","CT":"使用示例：","CL":"#333"},{"NT":"code","LG":"javascript","CT":"class DBQuery extends AsyncResource {\n  constructor(db) {\n    super('DBQuery');\n    this.db = db;\n  }\n\n  getInfo(query, callback) {\n    this.db.get(query, (err, data) =&gt; {\n      this.runInAsyncScope(callback, null, err, data);\n    });\n  }\n\n  close() {\n    this.db = null;\n    this.emitDestroy();\n  }\n}"}]},{"NT":"floor","CTS":[{"NT":"h","CT":"静态方法：AsyncResource.bind(fn[, type[, thisArg]])","CL":"#333"},{"NT":"floor","CTS":[{"NT":"h","CT":"历史变更","CL":"#333"},{"NT":"table","CTS":[["版本","改变"],["v17.8.0","改变默认行为，当 thisArg 参数的值为 undefined，则方法会使用调用者的 this。"],["v16.0.0","增加可选参数 thisArg。"],["v14.8.0, v12.19.0","于 v14.8.0, v12.19.0 版本被添加。"]]}]},{"NT":"list","CTS":[{"NT":"li","CT":"``fn``:Function | 绑定到当前执行上下文的函数。","CL":"#333"},{"NT":"li","CT":"``type``:string | 与 AsyncResource 相关联的可选名称。","CL":"#333"},{"NT":"li","CT":"``thisArg``:any","CL":"#333"}],"OL":false},{"NT":"p","CT":"将给定的函数绑定到当前执行上下文。","CL":"#333"},{"NT":"p","CT":"返回的函数会有一个 asyncResource 属性(此属性引用自一个绑定该函数的 AsyncResource 实例)。","CL":"#333"}]},{"NT":"floor","CTS":[{"NT":"h","CT":"asyncResource.bind(fn[, thisArg])","CL":"#333"},{"NT":"floor","CTS":[{"NT":"h","CT":"历史变更","CL":"#333"},{"NT":"table","CTS":[["版本","改变"],["v17.8.0","改变默认行为，当 thisArg 参数的值为 undefined，则方法会使用调用者的 this。"],["v16.0.0","增加可选参数 thisArg。"],["v14.8.0, v12.19.0","于 v14.8.0, v12.19.0 版本被添加。"]]}]},{"NT":"list","CTS":[{"NT":"li","CT":"``fn``:Function | 绑定到 AsyncResource 的函数。","CL":"#333"},{"NT":"li","CT":"``thisArg``:any","CL":"#333"}],"OL":false},{"NT":"p","CT":"将给定的要执行的函数绑定到 AsyncResource 的作用域。","CL":"#333"},{"NT":"p","CT":"此方法返回的函数会有一个 asyncResource 属性，此属性是该函数绑定到的 AsyncResource 实例的引用。","CL":"#333"}]},{"NT":"floor","CTS":[{"NT":"h","CT":"asyncResource.runInAsyncScope(fn[, thisArg, ...args])","CL":"#333"},{"NT":"p","CT":"于版本 v9.6.0 被添加。","CL":"#333"},{"NT":"list","CTS":[{"NT":"li","CT":"``fn``:Function | 在异步 resourse 执行上下文中被调用的函数。","CL":"#333"},{"NT":"li","CT":"``thisArg``:any | ``fn``调用的接收器。","CL":"#333"},{"NT":"li","CT":"``...args``:any | 可选的传给``fn``的参数。","CL":"#333"}],"OL":false},{"NT":"p","CT":"在异步 resourse 的执行上下文中使用传入的参数调用传入的函数。这会创建上下文，在回调函数前触发 AsyncHooks，调用``fn``，在回调函数后触发 AsyncHooks，最厚重置原来的执行上下文。","CL":"#333"}]},{"NT":"floor","CTS":[{"NT":"h","CT":"asyncResource.emitDestroy()","CL":"#333"},{"NT":"list","CTS":[{"NT":"li","CT":"``Returns``:AsyncResourse | 一个 asyncResource 实例的引用。","CL":"#333"}],"OL":false},{"NT":"p","CT":"调用所有的 destroy 钩子。这只能被调用一次。如果此方法被调用超过一次，则会抛出错误。此方法必须被手动调用。如果一个 resourse 被 GC 回收，则该实例的 destroy 钩子将永远不能被触发。","CL":"#333"}]},{"NT":"floor","CTS":[{"NT":"h","CT":"asyncResource.asyncId()","CL":"#333"},{"NT":"list","CTS":[{"NT":"li","CT":"``Returns``:number | 被分配给 resourse 的独一无二的 asyncId 。","CL":"#333"}],"OL":false}]},{"NT":"floor","CTS":[{"NT":"h","CT":"asyncResource.triggerAsyncId()","CL":"#333"},{"NT":"list","CTS":[{"NT":"li","CT":"``Returns``:number | 与被传给 AsyncResource 构造器的 triggerAsyncId 相同的 ID 。","CL":"#333"}],"OL":false}]},{"NT":"floor","CTS":[{"NT":"h","CT":"在 Worker 线程池中使用 AsyncResource","CL":"#333"},{"NT":"p","CT":"下面的例子展示了如何使用 AsyncResource 类来正确地在 Worker 线程池中提供异步追踪功能。其它类型的 resource 池，例如数据库连接池，也可以遵循类似的模型。","CL":"#333"},{"NT":"p","CT":"假如有一个任务是将两个数字相加，在一个叫做 //task_processor.js// 的文件中加入以下内容：","CL":"#333"},{"NT":"code","LG":"javascript","CT":"import { parentPort } from 'node:worker_threads';\nparentPort.on('message', (task) =&gt; {\n  parentPort.postMessage(task.a + task.b);\n});"},{"NT":"p","CT":"一个围绕它运行的 Worker 池可以使用下面的结构：","CL":"#333"},{"NT":"code","LG":"javascript","CT":"import { AsyncResource } from 'node:async_hooks';\nimport { EventEmitter } from 'node:events';\nimport path from 'node:path';\nimport { Worker } from 'node:worker_threads';\n\nconst kTaskInfo = Symbol('kTaskInfo');\nconst kWorkerFreedEvent = Symbol('kWorkerFreedEvent');\n\nclass WorkerPoolTaskInfo extends AsyncResource {\n  constructor(callback) {\n    super('WorkerPoolTaskInfo');\n    this.callback = callback;\n  }\n\n  done(err, result) {\n    this.runInAsyncScope(this.callback, null, err, result);\n    this.emitDestroy();\n    // `TaskInfo` 的 emitDestroy 方法\n    // 只能被调用一次。\n  }\n}\n\nexport default class WorkerPool extends EventEmitter {\n  constructor(numThreads) {\n    super();\n    this.numThreads = numThreads;\n    this.workers = [];\n    this.freeWorkers = [];\n    this.tasks = [];\n\n    for (let i = 0; i &lt; numThreads; i++)\n      this.addNewWorker();\n\n    // 每当 kWorkerFreedEvent 事件被 emit 时，\n    // 调度队列中下一个待处理的任务(如果有的话)。\n    this.on(kWorkerFreedEvent, () =&gt; {\n      if (this.tasks.length &gt; 0) {\n        const { task, callback } = this.tasks.shift();\n        this.runTask(task, callback);\n      }\n    });\n  }\n\n  addNewWorker() {\n    const worker = new Worker(new URL('task_processer.js', import.meta.url));\n    worker.on('message', (result) =&gt; {\n      // 如果成功，则调用传给`runTask`的回调函数，\n      // 并移除与该 Worker 相关联的`TaskInfo`，\n      // 且再次将其标记为 free。\n      worker[kTaskInfo].done(null, result);\n      worker[kTaskInfo] = null;\n      this.freeWorkers.push(worker);\n      this.emit(kWorkerFreedEvent);\n    });\n    worker.on('error', (err) =&gt; {\n      // 如果发生未捕获的错误(uncaught exception)：\n      // 调用传入的回调函数发生错误。\n      if (worker[kTaskInfo])\n        worker[kTaskInfo].done(err, null);\n      else\n        this.emit('error', err);\n      // 从列表中移除该 Worker，\n      // 并启用一个新的 Worker 来代替原来的那一个。\n      this.workers.splice(this.workers.indexOf(worker), 1);\n      this.addNewWorker();\n    });\n    this.workers.push(worker);\n    this.freeWorkers.push(worker);\n    this.emit(kWorkerFreedEvent);\n  }\n\n  runTask(task, callback) {\n    if (this.freeWorkers.length === 0) {\n      // 没有空闲的线程，请等到某个 worker 线程空闲时。\n      this.tasks.push({ task, callback });\n      return;\n    }\n\n    const worker = this.freeWorkers.pop();\n    worker[kTaskInfo] = new WorkerPoolTaskInfo(callback);\n    worker.postMessage(task);\n  }\n\n  close() {\n    for (const worker of this.workers) worker.terminate();\n  }\n}\n"},{"NT":"p","CT":"没有由 WorkerPoolTaskInfo 对象添加的显式追踪，你会发现这些回调函数是与单个的 Worker 对象相关联的。然而，Worker 的创建并不与任务的创建相关联，也不提供任务何时安排的信息。","CL":"#333"},{"NT":"hr"},{"NT":"p","CT":"Worker 池可以像下面这样使用：","CL":"#333"},{"NT":"code","LG":"javascript","CT":"import WorkerPool from './worker_pool.js';\nimport os from 'node:os';\n\nconst pool = new WorkerPool(os.cpus().length);\n\nlet finished = 0;\nfor (let i = 0; i &lt; 10; i++) {\n  pool.runTask({ a: 42, b: 100 }, (err, result) =&gt; {\n    console.log(i, err, result);\n    if (++finished === 10)\n      pool.close();\n  });\n}"}]},{"NT":"floor","CTS":[{"NT":"h","CT":"将 AsyncResource 与 EventEmitter 相整合","CL":"#333"},{"NT":"p","CT":"由 EventEmitter 触发的事件监听器可能会运行在一个与调用 eventEmitter.on() 不同的执行上下文。","CL":"#333"},{"NT":"p","CT":"下面的这个例子展示了如何使用 AsyncResource 类来正确地将一个事件监听器与正确的执行上下文相关联。同样的方法也可以用在 Stream 和类似的事件驱动的类上","CL":"#333"},{"NT":"code","LG":"javascript","CT":"import { createServer } from 'node:http';\nimport { AsyncResource, executionAsyncId } from 'node:async_hooks';\n\nconst server = createServer((req, res) =&gt; {\n  req.on('close', AsyncResource.bind(() =&gt; {\n    // 执行上下文被绑定到外部的作用域。\n  }));\n  req.on('close', () =&gt; {\n    // 执行上下文被绑定到使 'close' emit 的作用域。\n  });\n  res.end();\n}).listen(3000);"}]}]}