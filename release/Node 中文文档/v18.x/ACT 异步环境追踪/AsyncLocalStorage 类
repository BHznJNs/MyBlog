{"NM":"AsyncLocalStorage 类","CTS":[{"NT":"h","CT":"AsyncLocalStorage 类","CL":"#333"},{"NT":"floor","CTS":[{"NT":"h","CT":"历史变更","CL":"#333"},{"NT":"table","CTS":[["版本","改变"],["v16.4.0","此类的稳定性从实验性(Experimental)改为稳定的(Stable)。"],["v13.10.0, v12.17.0","于 v13.10.0, v12.17.0 版本被添加。"]]}]},{"NT":"p","CT":"此类构造的实例能够存储连续的异步操作。","CL":"#333"},{"NT":"p","CT":"虽然你可以创建自己的基于``node:async_hooks``模块的实现，但由于``AsyncLocalStorage``高性能和内存安全(其中包含不易实现的重大优化)，它应当作为你的首选。","CL":"#333"},{"NT":"p","CT":"下面的这个例子使用``AsyncLocalStorage``构建了一个简易的日志工具，可用于给每个 HTTP 请求分配编号并且在每次请求时输出的信息中包含这些编号。","CL":"#333"},{"NT":"code","LG":"javascript","CT":"import http from 'node:http';\nimport { AsyncLocalStorage } from 'node:async_hooks';\n\nconst asyncLocalStorage = new AsyncLocalStorage();\n\nfunction logWithId(msg) {\n  const id = asyncLocalStorage.getStore();\n  console.log(`${id !== undefined ? id : '-'}:`, msg);\n}\n\nlet idSeq = 0;\nhttp.createServer((req, res) =&gt; {\n  asyncLocalStorage.run(idSeq++, () =&gt; {\n    logWithId('start');\n    // 这里可以认为是一个异步操作链。\n    setImmediate(() =&gt; {\n      logWithId('finish');\n      res.end();\n    });\n  });\n}).listen(8080);\n\nhttp.get('http://localhost:8080');\nhttp.get('http://localhost:8080');\n// Prints:\n//   0: start\n//   1: start\n//   0: finish\n//   1: finish"},{"NT":"p","CT":"每一个``AsyncLocalStorage``的实例控制一个独立的存储空间。多个实例可以同时安全存在，没有互相间数据干扰的风险。","CL":"#333"},{"NT":"floor","CTS":[{"NT":"h","CT":"new AsyncLocalStorage()","CL":"#333"},{"NT":"p","CT":"于 v13.10.0, v12.17.0 版本被添加。","CL":"#333"},{"NT":"p","CT":"创建一个``AsyncLocalStorage``的实例。Store 只有在 run 方法的回调函数内或在 enterWith() 后才能被获取。","CL":"#333"}]},{"NT":"floor","CTS":[{"NT":"h","CT":"～.disable()","CL":"#333"},{"NT":"p","CT":"于 v13.10.0, v12.17.0 版本被添加。","CL":"#333"},{"NT":"p","CT":"稳定性：实验性(Experimental)","CL":"#ca5010"},{"NT":"p","CT":"禁用``AsyncLocalStorage``的实例。调用之后调用``asyncLocalStorage.getStore()``会返回 undefined，直到``asyncLocalStorage.run()``或``asyncLocalStorage.enterWith()``被再次调用。","CL":"#333"},{"NT":"p","CT":"调用此方法时，所有链接这个实例的环境都会被退出。","CL":"#333"},{"NT":"p","CT":"此方法必须要在 asyncLocalStorage 实例被垃圾回收前调用。此方法不会对 asyncLocalStorage 返回的 store 生效，因为这些对象会与相应的异步资源一起被垃圾回收。","CL":"#333"},{"NT":"p","CT":"请在一个``asyncLocalStorage``实例不再被使用时调用此方法。","CL":"#333"}]},{"NT":"floor","CTS":[{"NT":"h","CT":"～.getStore()","CL":"#333"},{"NT":"p","CT":"于 v13.10.0, v12.17.0 版本被添加。","CL":"#333"},{"NT":"list","CTS":[{"NT":"li","CT":"``Returns``:any","CL":"#333"}],"OL":false},{"NT":"p","CT":"返回当前的 store 。如果在异步环境外调用``asyncLocalStorage.run()``或者``asyncLocalStorage.enterWith()``进行初始化后再调用此方法，将返回 undefined。","CL":"#333"}]},{"NT":"floor","CTS":[{"NT":"h","CT":"～.enterWith(store)","CL":"#333"},{"NT":"p","CT":"于 v13.11.0, v12.17.0 版本被添加。","CL":"#333"},{"NT":"p","CT":"稳定性：实验性(Experimental)","CL":"#ca5010"},{"NT":"list","CTS":[{"NT":"li","CT":"``store``:any","CL":"#333"}],"OL":false},{"NT":"p","CT":"过渡到当前同步执行的剩余部分的上下文，然后通过后续的异步调用持久化存储。","CL":"#333"},{"NT":"p","CT":"例如：","CL":"#333"},{"NT":"code","LG":"javascript","CT":"const store = { id: 1 };\n// 用指定的对象替换先前的 store。\nasyncLocalStorage.enterWith(store);\n\n\n// 返回 store 对象。\nasyncLocalStorage.getStore();\nsomeAsyncOperation(() =&gt; {\n  // 返回相同的对象。\n  asyncLocalStorage.getStore();\n});"},{"NT":"p","CT":"这个过渡会在整个同步运行过程中持续。这意味着，例如，如果在事件处理程序中输入上下文，则后续事件处理程序也将在该上下文中运行，除非特别使用``AsyncResource``绑定到其它上下文。这就是为什么 run() 方法的优先级比 enterWith() 更高，除非有充足的理由使用此方法。","CL":"#333"},{"NT":"code","LG":"javascript","CT":"const store = { id: 1 };\n\nemitter.on('my-event', () =&gt; {\n  asyncLocalStorage.enterWith(store);\n});\nemitter.on('my-event', () =&gt; {\n  asyncLocalStorage.getStore();\n  // 返回相同的对象。\n});\n\nasyncLocalStorage.getStore();\n// 返回 undefined。\nemitter.emit('my-event');\nasyncLocalStorage.getStore();\n// 返回相同的对象。"}]},{"NT":"floor","CTS":[{"NT":"h","CT":"～.run(store, callback[, ...args])","CL":"#333"},{"NT":"p","CT":"于 v13.10.0, v12.17.0 版本被添加。","CL":"#333"},{"NT":"list","CTS":[{"NT":"li","CT":"``store``:any","CL":"#333"},{"NT":"li","CT":"``callback``:Function","CL":"#333"},{"NT":"li","CT":"``...args``:any","CL":"#333"}],"OL":false},{"NT":"p","CT":"在上下文中同步地运行一个函数，并且返回这个函数的返回值。store 不能在函数的外部读取。对于在回调函数内的任何异步操作，store 都是可读的。","CL":"#333"},{"NT":"p","CT":"可选的参数``...args``会被传给回调函数。","CL":"#333"},{"NT":"p","CT":"如果回调函数抛出了一个错误，则该错误也会被此方法抛出。堆栈追踪不会被此调用影响并且此上下文会退出。","CL":"#333"},{"NT":"hr"},{"NT":"p","CT":"示例：","CL":"#333"},{"NT":"code","LG":"javascript","CT":"const store = { id: 2 };\ntry {\n  asyncLocalStorage.run(store, () =&gt; {\n    asyncLocalStorage.getStore();\n    // 返回 store 对象。\n    setTimeout(() =&gt; {\n      asyncLocalStorage.getStore();\n      // 返回 store 对象。\n    }, 200);\n    throw new Error();\n  });\n} catch (e) {\n  asyncLocalStorage.getStore();\n  // 返回 undefined。\n  // 错误会在这里被 catch。\n}\n\n"}]},{"NT":"floor","CTS":[{"NT":"h","CT":"～.exit(callback[, ...args])","CL":"#333"},{"NT":"p","CT":"于 v13.10.0, v12.17.0 版本被添加。","CL":"#333"},{"NT":"p","CT":"稳定性：实验性(Experimental)","CL":"#ca5010"},{"NT":"list","CTS":[{"NT":"li","CT":"``callback``:Function","CL":"#333"},{"NT":"li","CT":"``...args``:any","CL":"#333"}],"OL":false},{"NT":"p","CT":"在当前上下文外同步地运行一个函数，并且返回该函数的返回值。在回调函数内和回调函数中的异步操作中无法读取 store。在回调函数内调用完成的 getStore() 都会返回 undefined。","CL":"#333"},{"NT":"p","CT":"可选的参数``...args``会被传给回调函数。","CL":"#333"},{"NT":"p","CT":"如果回调函数抛出了一个错误，则该错误也会被此方法抛出。堆栈追踪不会被此调用影响并且会重新进入上下文。","CL":"#333"},{"NT":"hr"},{"NT":"p","CT":"示例：","CL":"#333"},{"NT":"code","LG":"javascript","CT":"// 在一个调用内运行。\ntry {\n  asyncLocalStorage.getStore();\n  // 返回 store 对象或值。\n  asyncLocalStorage.exit(() =&gt; {\n    asyncLocalStorage.getStore();\n    // 返回 undefined。\n    throw new Error();\n  });\n} catch (e) {\n  asyncLocalStorage.getStore();\n  // 返回相同的对象或值。\n  // 错误会在这里被 catch。\n}"}]},{"NT":"floor","CTS":[{"NT":"h","CT":"与 await/async 一起使用","CL":"#333"},{"NT":"p","CT":"如果在一个 async 函数内，在上下文中只要运行一个 await 调用，必须使用以下的模式：","CL":"#333"},{"NT":"code","LG":"javascript","CT":"async function fn() {\n  await asyncLocalStorage.run(new Map(), () =&gt; {\n    asyncLocalStorage.getStore().set('key', value);\n    return foo();\n    // foo 的返回值会被等待。\n  });\n}"},{"NT":"p","CT":"在这个例子中，store 只有在回调函数和被 foo 调用的函数中可用。在 run 方法之外，调用 getStore 方法会返回 undefined。","CL":"#333"}]},{"NT":"floor","CTS":[{"NT":"h","CT":"问题排除：上下文缺失","CL":"#333"},{"NT":"p","CT":"在多数例子中，AsyncLocalStorage 是不会出错的。在一些比较稀有的情况中，store 在异步操作下缺失。","CL":"#333"},{"NT":"p","CT":"如果你的代码是基于回调函数的，你可以使用``util.promisify()``来 promisify(可以理解为 promise 化) 它，这样代码就可以使用原生 promise 运行。","CL":"#333"},{"NT":"p","CT":"如果你想要使用基于回调函数的 API，或者你的代码使用了自定义的 thenable 实现，请使用``AsyncResource``类将异步操作和正确的执行上下文相关联。在你怀疑的调用与上下文缺失有关之后，通过记录``asyncLocalStorage.getStore()``的返回值来找到对应的函数调用。当``asyncLocalStorage.getStore()``返回 undefined 时，最后一个被调用的回调函数最可能与上下文缺失有关。","CL":"#333"}]}]}