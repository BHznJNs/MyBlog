{"NM":"钩子回调函数","CTS":[{"NT":"h","CT":"Hook Callbacks | 钩子回调函数","CL":"#333"},{"NT":"p","CT":"在异步事件生命周期中的关键事件被分成四类：实例化时、回调函数被调用 前/后 时、实例被销毁时。","CL":"#333"},{"NT":"floor","CTS":[{"NT":"h","CT":"init 钩子","CL":"#333"},{"NT":"p","CT":"init(asyncId, type, triggerAsyncId, resource)","CL":"#333"},{"NT":"list","CTS":[{"NT":"li","CT":"``asyncId``:number | 异步 resource 独一无二的 ID 。","CL":"#333"},{"NT":"li","CT":"``type``:string | 该异步 resource 的类型。","CL":"#333"},{"NT":"li","CT":"``triggerAsyncId``:number | 该异步 resource 创建时的执行作用域的 ID 。","CL":"#333"},{"NT":"li","CT":"``resource``:Object | 对代表异步操作的 resource 的引用，需要在对象销毁时释放。","CL":"#333"}],"OL":false},{"NT":"p","CT":"此钩子会在一个有可能触发异步事件的类构造时调用。这不意味着实例必定会在 destroy 钩子被调用前调用 before/after 钩子，只是存在这种可能性。","CL":"#333"},{"NT":"p","CT":"这种行为可以通过启用一个 resource 再在该 resource 可用之前将其关闭来观察到。下面这段代码演示了这种方法。","CL":"#333"},{"NT":"code","LG":"javascript","CT":"import { createServer } from 'node:net';\n\ncreateServer().listen(function() { this.close(); });\n// 或者\nclearTimeout(setTimeout(() =&gt; {}, 10));"},{"NT":"p","CT":"每一个新的 resource 都会在当前 Node.js 实例的作用域中被分配一个独一无二的 ID 。","CL":"#333"},{"NT":"floor","CTS":[{"NT":"h","CT":"type | 类型","CL":"#333"},{"NT":"p","CT":"``type``参数是一个用来标识调用了 init 钩子的 resource 类型的字符串。通常来说，它会与 resource 的构造器的名称相对应。","CL":"#333"},{"NT":"p","CT":"合法的值如下：","CL":"#333"},{"NT":"code","LG":"text","CT":"FSEVENTWRAP, FSREQCALLBACK, GETADDRINFOREQWRAP,\nGETNAMEINFOREQWRAP, HTTPINCOMINGMESSAGE,\nHTTPCLIENTREQUEST, JSSTREAM, PIPECONNECTWRAP,\nPIPEWRAP, PROCESSWRAP, QUERYWRAP, SHUTDOWNWRAP,\nSIGNALWRAP, STATWATCHER, TCPCONNECTWRAP,\nTCPSERVERWRAP, TCPWRAP, TTYWRAP, UDPSENDWRAP,\nUDPWRAP, WRITEWRAP, ZLIB, SSLCONNECTION,\nPBKDF2REQUEST, RANDOMBYTESREQUEST, TLSWRAP,\nMicrotask, Timeout, Immediate, TickObject"},{"NT":"p","CT":"这些值可能在未来的 Node.js 版本中改变，并且用户的 AsyncResource 也可能提供其它的值。","CL":"#333"}]}]}]}