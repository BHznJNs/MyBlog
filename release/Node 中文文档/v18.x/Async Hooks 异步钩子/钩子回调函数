{"NM":"钩子回调函数","CTS":[{"NT":"h","CT":"Hook Callbacks | 钩子回调函数","CL":"#333"},{"NT":"p","CT":"在异步事件生命周期中的关键事件被分成四类：实例化时、回调函数被调用 前/后 时、实例被销毁时。","CL":"#333"},{"NT":"floor","CTS":[{"NT":"h","CT":"init 钩子","CL":"#333"},{"NT":"p","CT":"init(asyncId, type, triggerAsyncId, resource)","CL":"#333"},{"NT":"list","CTS":[{"NT":"li","CT":"``asyncId``:number | 异步 resource 独一无二的 ID 。","CL":"#333"},{"NT":"li","CT":"``type``:string | 该异步 resource 的类型。","CL":"#333"},{"NT":"li","CT":"``triggerAsyncId``:number | 该异步 resource 创建时的执行作用域的 ID 。","CL":"#333"},{"NT":"li","CT":"``resource``:Object | 对代表异步操作的 resource 的引用，需要在对象销毁时释放。","CL":"#333"}],"OL":false},{"NT":"p","CT":"此钩子会在一个有可能触发异步事件的类构造时调用。这不意味着实例必定会在 destroy 钩子被调用前调用 before/after 钩子，只是存在这种可能性。","CL":"#333"},{"NT":"p","CT":"这种行为可以通过启用一个 resource 再在该 resource 可用之前将其关闭来观察到。下面这段代码演示了这种方法。","CL":"#333"},{"NT":"code","LG":"javascript","CT":"import { createServer } from 'node:net';\n\ncreateServer().listen(function() { this.close(); });\n// 或者\nclearTimeout(setTimeout(() =&gt; {}, 10));"},{"NT":"p","CT":"每一个新的 resource 都会在当前 Node.js 实例的作用域中被分配一个独一无二的 ID 。","CL":"#333"},{"NT":"floor","CTS":[{"NT":"h","CT":"type | 类型","CL":"#333"},{"NT":"p","CT":"``type``参数是一个用来标识调用了 init 钩子的 resource 类型的字符串。通常来说，它会与 resource 的构造器的名称相对应。","CL":"#333"},{"NT":"p","CT":"合法的值如下：","CL":"#333"},{"NT":"code","LG":"text","CT":"FSEVENTWRAP, FSREQCALLBACK, GETADDRINFOREQWRAP,\nGETNAMEINFOREQWRAP, HTTPINCOMINGMESSAGE,\nHTTPCLIENTREQUEST, JSSTREAM, PIPECONNECTWRAP,\nPIPEWRAP, PROCESSWRAP, QUERYWRAP, SHUTDOWNWRAP,\nSIGNALWRAP, STATWATCHER, TCPCONNECTWRAP,\nTCPSERVERWRAP, TCPWRAP, TTYWRAP, UDPSENDWRAP,\nUDPWRAP, WRITEWRAP, ZLIB, SSLCONNECTION,\nPBKDF2REQUEST, RANDOMBYTESREQUEST, TLSWRAP,\nMicrotask, Timeout, Immediate, TickObject"},{"NT":"p","CT":"这些值可能在未来的 Node.js 版本中改变，并且用户的 AsyncResource 也可能提供其它的值。","CL":"#333"},{"NT":"p","CT":"并且，也存在``PROMISE``类型的 resource，这被用于追踪``Promise``实例和被其安排的异步操作。\n","CL":"#333"},{"NT":"p","CT":"在使用公共的``embedder``API 时，用户可以定义自己的``type``。","CL":"#333"},{"NT":"p","CT":"``type``名称的重复是有可能的。因此你最好使用独特的前缀，例如 npm 包名，以防止在监听钩子时出现重复。","CL":"#333"}]},{"NT":"floor","CTS":[{"NT":"h","CT":"triggerAsyncId | 捕获器异步 ID","CL":"#333"},{"NT":"p","CT":"``triggerAsyncId`` 是导致新异步资源初始化并且使得``init``钩子被调用的异步资源的``asyncId``。这与只当异步资源被创建时显示的``async_hooks.executionAsyncId()``不同，因为``triggerAsyncId``会展现一个异步资源被创建的原因。","CL":"#333"},{"NT":"p","CT":"下面是一段简单的示例代码：","CL":"#333"},{"NT":"code","LG":"javascript","CT":"import { createHook, executionAsyncId } from 'node:async_hooks';\nimport { stdout } from 'node:process';\nimport net from 'node:net';\n\ncreateHook({\n  init(asyncId, type, triggerAsyncId) {\n    const eid = executionAsyncId();\n    fs.writeSync(\n      stdout.fd,\n      `${type}(${asyncId}): ` +\n      `trigger: ${triggerAsyncId}` +\n      `execution: ${eid}\\n`\n    );\n  }\n}).enable();\n\nnet.createServer((conn) =&gt; {}).listen(8080);"},{"NT":"p","CT":"当使用``nc localhost 8080``访问服务器时，输出：","CL":"#333"},{"NT":"code","LG":"text","CT":"TCPSERVERWRAP(5): trigger: 1 execution: 1\nTCPWRAP(7): trigger: 5 execution: 0"},{"NT":"p","CT":"``TCPSERVERWRAP``是收到连接的服务器。 ","CL":"#333"},{"NT":"p","CT":"``TCPWRAP``是来自客户端的新连接。当创建一个新的连接，会立刻构造一个``TCPWrap``实例。这发生在任何 JavaScript 堆栈之外（一个值为 0 的``executionAsyncId()``意味着这会被 C++ 执行并且在这之中不存在任何 Javascript 堆栈）。","CL":"#333"}]}]}]}