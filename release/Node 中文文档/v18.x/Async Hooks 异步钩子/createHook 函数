{"NM":"createHook 函数","CTS":[{"NT":"h","CT":"async_hooks.createHook 函数","CL":"#333"},{"NT":"p","CT":"async_hooks.createHook(callbacks)","CL":"#333"},{"NT":"p","CT":"于 v8.1.0 版本被添加。","CL":"#333"},{"NT":"list","CTS":[{"NT":"li","CT":"``callbacks``:Object | 要注册的钩子回调函数。","CL":"#333"},{"NT":"list","OL":false,"CTS":[{"NT":"li","CT":"``init``:Function","CL":"#333"},{"NT":"li","CT":"``before``:Function","CL":"#333"},{"NT":"li","CT":"``after``:Function","CL":"#333"},{"NT":"li","CT":"``destroy``:Function","CL":"#333"},{"NT":"li","CT":"``promiseResolve``:Function","CL":"#333"}]},{"NT":"li","CT":"``Returns``:AsyncHook | 一个 AsyncHook 实例，用于启用和禁用挂载在实例上的钩子。","CL":"#333"}],"OL":false},{"NT":"p","CT":"为不同生命周期调用的函数进行注册。","CL":"#333"},{"NT":"p","CT":"在一个 resource 的生命周期中，``init()`` / ``before()`` / ``after()`` / ``destroy()``这些钩子会被相应的异步操作调用。","CL":"#333"},{"NT":"p","CT":"所有的异步钩子都是可选的。例如，当一个 resource 只有其销毁需要被追踪的时候，只需要传入 destroy 钩子。所有钩子的使用详情请见 Hook Callbacks 部分。","CL":"#333"},{"NT":"code","LG":"javascript","CT":"import { createHook } from 'node:async_hooks';\n\nconst asyncHook = createHook({\n  init(asyncId, type, triggerAsyncId, resource) { },\n  destroy(asyncId) { }\n});"},{"NT":"p","CT":"钩子可以通过原型链继承。","CL":"#333"},{"NT":"code","LG":"javascript","CT":"class MyAsyncCallbacks {\n  init(\n    asyncId, type,\n    triggerAsyncId, resource,\n) { }\n  destroy(asyncId) {}\n}\n\nclass MyAddedCallback\nextends MyAsyncCallbacks {\n  before(asyncId) { }\n  after(asyncId) { }\n}\n\nconst asyncHook = async_hooks.createHook(\n    new MyAddedCallbacks()\n);"},{"NT":"p","CT":"因为 promise 作为异步的 resource，且生命周期可以被通过异步钩子机制追踪，所以 init, before, after, destroy 钩子都不能是返回 promise 的异步函数。","CL":"#333"},{"NT":"floor","CTS":[{"NT":"h","CT":"错误处理","CL":"#333"},{"NT":"p","CT":"如果一个异步钩子报错了，该程序会打印出堆栈追踪并退出。并且该程序打印出的堆栈追踪与一个 uncaught exception 的相同，只是所有的 uncaughtException 监听器都会被移除，因此程序被强制退出。程序的 exit 回调函数仍会被调用，除非 node 带上了``--abort-on-uncaught-exception``参数，这种情况下，程序会在保留 Core 文件的同时打印堆栈追踪并退出。","CL":"#333"},{"NT":"p","CT":"这种错误处理方式，是因为这些回调函数运行在对象生命周期中潜在不稳定的点，例如，对象的构造和销毁。因此，为了防止意料之外的程序中断而降低进程(bring down the process)是必要的。如果进行全面分析以确保异常可以遵循正常的控制流程而不会产生意外的副作用，这可能会在未来发生变化。","CL":"#333"}]},{"NT":"floor","CTS":[{"NT":"h","CT":"在 AsyncHook 回调函数中打印输出","CL":"#333"},{"NT":"p","CT":"由于输出到控制台这一行为是异步操作，``console.log()``会引发 AsyncHook 回调函数被调用。在一个 AsyncHook 回调函数中使用``console.log()``或类似的异步操作会导致无限递归。于此，有一个简单的解决方法：在 debug 的时候使用同步方法例如``fs.writeFileSync(file, msg, flag)``。这会将信息输出到文件并且不会递归地请求 AsyncHook 。","CL":"#333"},{"NT":"code","LG":"javascript","CT":"import { writeFileSync } from 'node:fs';\nimport { format } from 'node:util';\n\nfunction debug(...args) {\n  // 在一个 AsyncHook 回调函数内\n  // debug 时，使用像这样的函数。\n  writeFileSync(\n    'log.out',\n    `${format(...args)}\\n`,\n    { flag: 'a' }\n  );\n}"},{"NT":"p","CT":"如果在打日志的时候需要执行异步操作，持续追踪使用 AsyncHook 自身提供的信息来引发的异步操作是可能的。当一个引发了 AsyncHook 回调函数的日志操作被调用时，该操作必须被略过。通过这些操作，在不同情况下的无限递归会被打破。","CL":"#333"}]}]}